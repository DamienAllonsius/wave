<canvas id=a width=800 height=600></canvas>

<script>

// Init
c=a.getContext('2d');
x_min = -1;
x_max = 1;
y_min = -1;
y_max = 1;
Nx = 100;
Ny = Nx;
NT = 1000;
T_max = 2;
dx = (x_max - x_min) / (Nx - 1);
dy = (y_max - y_min) / (Ny - 1);
X = [];
Y = [];
Z0 = [];

// Compute Z0
for(i = 0; i < Nx; i++){
  X[i] = [];
  Y[i] = [];
  Z0[i] = [];
  for(j = 0; j < Ny; j++){
    X[i][j] = x_min + j * dx;
    Y[i][j] = y_min + i * dy;
    Z0[i][j] = 10 * Math.exp(-10 * X[i][j] ** 2) * Math.exp(-10 * Y[i][j] ** 2);
  }
}

// Loop
P = [];
w = 0;
setInterval(e=>{
  a.width ^= 0;
  //w += .01;
  for(X = 99; X--;){
    P[X] = [];
    for(Y = 99; Y--;){
      x = X * 4 - 200;
      y = Y * 4 - 200;
      z = -Z0[X][Y]*10;
      p=Math.atan2(y,x)-w;
      d=Math.hypot(y,x);
      x=Math.sin(p)*d;
      y=Math.cos(p)*d;
      p=Math.atan2(y,z)+1.2;
      d=Math.hypot(y,z);
      z=Math.sin(p)*d;
      y=Math.cos(p)*d;
      y+=400;
      P[X][Y] = [400+x/y*400, 400+z/y*400];
      c.moveTo(P[X][Y][0], P[X][Y][1]-100);
      try{c.lineTo(P[X][Y+1][0], P[X][Y+1][1]-100)}catch(e){};
      c.moveTo(P[X][Y][0], P[X][Y][1]-100);
      try{c.lineTo(P[X+1][Y][0], P[X+1][Y][1]-100)}catch(e){};
    }
  }
  c.stroke();
}, 33);



t_x_p = Zt => {
  var ret;
  for(var i = 1; i < Nx - 1; i++){
    for(var j = 2; j < Ny; j++){
      ret[i-1][j-2] = Zt[i][j];
    }
  }
  return ret;
}

t_y_p = Zt => {
  var ret;
  for(var i = 2; i < Nx; i++){
    for(var j = 1; j < Ny - 1; j++){
      ret[i-2][j-1] = Zt[i][j];
    }
  }
  return ret;
}


t_x_m = Zt => {
  var ret;
  for(var i = 1; i < Nx - 1; i++){
    for(var j = 0; j < Ny - 2; j++){
      ret[i-1][j] = Zt[i][j];
    }
  }
  return ret;
}


t_y_m = Zt => {
  var ret;
  for(var i = 0; i < Nx - 2; i++){
    for(var j = 1; j < Ny - 1; j++){
      ret[i][j-1] = Zt[i][j];
    }
  }
  return ret;
}

L = Zt => {
    Lx = 1/dx**2 * (t_x_p(Zt) - 2 * Zt[1:-1, 1:-1] + t_x_m(Zt))
    Ly = 1/dy**2 * (t_y_p(Zt) - 2 * Zt[1:-1, 1:-1] + t_y_m(Zt))
    return Lx + Ly
}

/*

def set_boundary_conditions(Z):
    Z[:,0] = Z[:,1]
    Z[:,-1] = Z[:,-2]
    Z[0,:] = Z[1,:]
    Z[-1,:] = Z[-2,:]
    return Z

    */
    


compute_wave_solution = Z0 => {
  Z0 = set_boundary_conditions(Z0);
  Z = [];
  for(var i = 0; i < NT; i++){
    Z[i] = [];
    for(var j = 0; j < NT; j++){
      Z[i][j] = [];
      for(var k = 0; k < NT; k++){
        Z[i][j][k] = 0;
      }
    }
  }

  Z[0] = Z0;
  
  Z[1] = Z0;

  for(var t = 1; t < NT - 1; t++){
  
  
    //Z[t+1, 1:-1, 1:-1] = (dt ** 2) * (0.5 * L(Z[t, :, :]) + 0.5 * L(Z[t-1, :, :])) + 2 * Z[t, 1:-1, 1:-1] - Z[t-1, 1:-1, 1:-1]
    //Z[t+1, :, :] = set_boundary_conditions(Z[t+1, :, :])
  }
  
  return Z;
}



</script>



<!--
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter

def plot_simualtion(X, Y, Z):
    fig = plt.figure()

    for t in range(NT):
        ax = fig.gca(projection='3d')
        # Customize the z axis.
        ax.set_zlim(0, 10)
        ax.zaxis.set_major_locator(LinearLocator(10))
        ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))

        ax.plot_surface(X, Y, Z[t, :, :], cmap=cm.coolwarm, linewidth=0, antialiased=False)
        plt.pause(0.01)
        plt.clf()

    plt.show()




def compute_wave_solution(Z0):
    Z0 = set_boundary_conditions(Z0)
    Z = np.zeros((NT, Nx, Ny))

    Z[0, :, :] = Z0
    Z[1, :, :] = Z0  # initial velocity = 0

    for t in range(1, NT-1):
        Z[t+1, 1:-1, 1:-1] = (dt ** 2) * (0.5 * L(Z[t, :, :]) + 0.5 * L(Z[t-1, :, :])) + 2 * Z[t, 1:-1, 1:-1] - Z[t-1, 1:-1, 1:-1]
        Z[t+1, :, :] = set_boundary_conditions(Z[t+1, :, :])

    return Z

x_min = -1
x_max = 1
y_min = -1
y_max = 1
Nx = 100
Ny = Nx
NT = 1000
T_max = 2


# Uniform discretization w.r.t x
x = np.linspace(x_min, x_max, Nx)
dx = x[1] - x[0]

# Uniform discretization w.r.t y
y = np.linspace(y_min, y_max, Ny)
dy = y[1] - y[0]

# Uniform discretization w.r.t time
dt = T_max / NT

# mesh x and y
X, Y = np.meshgrid(x, y)

Z0 = 10 * np.exp(- 10*X ** 2) * np.exp(- 10* Y ** 2)

Z = compute_wave_solution(Z0)

plot_simualtion(X, Y, Z)-->
